<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Regression modeling with complex survey data</title>
    <meta charset="utf-8" />
    <meta name="author" content="Stat 260, St. Clair" />
    <script src="libs/header-attrs/header-attrs.js"></script>
    <link href="libs/remark-css/default.css" rel="stylesheet" />
    <link href="libs/remark-css/default-fonts.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Regression modeling with complex survey data
## Week 10 (ch 11)
### Stat 260, St. Clair

---





### Goal:


- A regression model describes how a response `\(y\)` varies as a function of explanatory variables `\(x\)`

--

- Typical regression modeling goals:

1. Describe the relationship between variables.  

--

2. Predict a response `\(y\)` given `\(x\)`

--

3. Determine how changes in `\(x\)` **cause** changes in `\(y\)`


---

### Model-based regression: Stat 230


- Build a theoretical "universal" model for `\(y\)` given `\(x\)` that holds across populations


--

-  Describe a "data generating model" (DGM)

    - a stochastic model that “generates” the particular finite population of individuals


--

- A model comes with structural probabilistic assumptions that must be checked


---

### Model-based regression: Stat 230


- Variables: 
    - Response `\(Y\)`
    - Covariates (predictors/explanatory) `\(x\)`

--

- Simple linear regression model: describes the **conditional probability distribution of `\(\pmb{y}\)` given `\(\pmb{x}\)`**

`$$Y_i \mid x_i \sim N(\mu_i, \sigma^2) \ \ \ \mu_i = \beta_0 + \beta_1 x_i$$`


--

- Model assumptions:

(1) Linear relationship

(2) Constant variance

(3) Normally distributed 

(4) Independence


---

### Model-based regression: estimation

.large[
- Obtain data we believe was generated by a particular DGP 

- Use **maximum likelihood** inference methods to derive parameter estimates and SE for theoretical parameters `\(\beta_0\)`, `\(\beta_1\)`, and `\(\sigma\)`

    - only based on the model assumptions, not sampling weights!
]

--

.large[
- e.g. the slope estimate:
`$$\hat{\beta_1} = \dfrac{\sum_{i=1}^n x_iy_i - \dfrac{1}{n} \sum_{i=1}^n x_i \sum_{i=1}^n y_i}{ \sum_{i=1}^n x^2_i -  \dfrac{1}{n}\left(\sum_{i=1}^n x_i \right)^2}$$`
- But estimates and their SE's are highly dependent upon model assumptions (1), (2) and (4)
]


---

### Design-based regression: Stat 260

.large[
- Population parameters `\(B_0\)` and `\(B_1\)` are the "best fit" intercept and slope for the population trend
`$$y = B_0 + B_1 x$$`
- "best fit" means `\(B_0\)` and `\(B_1\)` minimize

`$$\sum_{i=1}^N (y_i - B_0 - B_1x_i)^2$$`
]
--

.large[
- e.g. the population slope is
`$$B_1 = \dfrac{\sum_{i=1}^N x_iy_i - \dfrac{1}{N} \sum_{i=1}^N x_i \sum_{i=1}^N y_i}{ \sum_{i=1}^N x^2_i -  \dfrac{1}{N}\left(\sum_{i=1}^N x_i \right)^2}$$`
]

---

### Design-based regression: estimation

.large[
-  `\(B_1\)` is just another population parameter to estimate using sampling weights

    - Model fit is not important since there is no model structure!
]

--

.large[
- e.g `\(B_1\)` is just a function of population totals so we use an appropriately weighted estimate:
`$$\hat{B}_1 = \dfrac{\sum_{i=1}^n w_ix_iy_i - \dfrac{1}{\sum_{i=1}^n w_i} \sum_{i=1}^n w_ix_i \sum_{i=1}^n w_iy_i}{ \sum_{i=1}^n w_ix^2_i -  \dfrac{1}{\sum_{i=1}^n w_i}\left(\sum_{i=1}^n w_ix_i \right)^2}$$`
- Shouldn't apply design-based parameter estimates `\(\hat{B}_0, \hat{B}_1\)` to other finite populations.

]

---

### Design-based vs model-based regression

.large[
- Can think of the finite population of `\(y_i\)`'s as being a realization from a "universal" DGM described earlier

    - then `\(B\)`'s should be close to `\(\beta\)`'s 
]

--
.large[
- If **estimates** of `\(B_1\)` and `\(\beta_1\)` differ by a lot, then this could indicate that the **model** is inadequate 

    - the model doesn't fit all subpopulations well
    
    - sampling weights are likely accounting for some unmeasured variable that is important to the relationship between `\(y\)` and `\(x\)`
]

--

.large[
- Models can include design variables

    - use stratification variables as covariates
    
    - fit a mixed-effects model with random cluster effects (Stat 330)
]

---

### Example: The population

.large[
- `anthrop` in `SDaA`
    - A population of 3000 late 19th century "criminals" (anthrop.csv)

- Goal: model height as a function of finger length


```r
pop &lt;- anthrop  # the finite pop.
str(pop)
## tibble [3,000 x 2] (S3: tbl_df/tbl/data.frame)
##  $ finger: num [1:3000] 10 10.3 9.9 10.2 10.2 10.3 10.4 10.7 10 10.1 ...
##  $ height: num [1:3000] 56 57 58 58 58 58 58 58 59 59 ...
##  - attr(*, "label")= chr "ANTHROP                         "
pop_lm &lt;- lm(height ~ finger, data=pop)
pop_lm
## 
## Call:
## lm(formula = height ~ finger, data = pop)
## 
## Coefficients:
## (Intercept)       finger  
##      30.179        3.056
```
]

---

### Example:  The population
.large[

&lt;img src="week_10_regression_files/figure-html/unnamed-chunk-2-1.svg" style="display: block; margin: auto;" /&gt;

]

---

### Example: The SRS of size 200 `anthsrs`
.large[

&lt;img src="week_10_regression_files/figure-html/unnamed-chunk-3-1.svg" style="display: block; margin: auto;" /&gt;


]

---

### Example: The SRS of size 200 `anthsrs`

.large[
- With an SRS, the model- and design-based estimates are the same (self-weighting).

- Model-based estimation:

```r
anthsrs_lm&lt;- lm(height~finger, data= anthsrs)   # model-based
broom::tidy(anthsrs_lm)
## # A tibble: 2 x 5
##   term        estimate std.error statistic  p.value
##   &lt;chr&gt;          &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;
## 1 (Intercept)    30.3      2.57       11.8 1.03e-24
## 2 finger          3.05     0.222      13.7 1.36e-30
```

]

---

### Example: The SRS of size 200 `anthsrs`

.large[
- Design-based estimation:

```r
anthsrs$N&lt;- 3000
anthsrs$wts&lt;- 3000/200
anthsrs_design&lt;- svydesign(id = ~1, 
                           fpc = ~N, 
                           weights = ~wts, 
                           data = anthsrs)
anthsrs_svylm&lt;- svyglm(height ~ finger, 
                       design = anthsrs_design)
broom::tidy(anthsrs_svylm)
## # A tibble: 2 x 5
##   term        estimate std.error statistic  p.value
##   &lt;chr&gt;          &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;
## 1 (Intercept)    30.3      2.46       12.3 2.60e-26
## 2 finger          3.05     0.213      14.3 2.12e-32
```

]

---

### Example: The SRS of size 200 `anthsrs`

.large[
- Finite population:
`$$B_1 = 3.056, \ \ B_0 =  30.179$$`

- Model-based slope estimate:
`$$\hat{\beta}_1 = 3.0453 (SE = 0.2217), \ \ \hat{\beta}_0 = 30.3162 (SE=2.5668)$$`

- Design-based slope estimate:
`$$\hat{B}_1 = 3.0453 (SE = 0.2126), \ \ \hat{B}_0 = 30.3162 (SE=2.4574)$$`
]

---

### Example:  unequal probability sample `anthuneq`

Shorter men have a higher inclusion probability
&lt;img src="week_10_regression_files/figure-html/unnamed-chunk-6-1.svg" style="display: block; margin: auto;" /&gt;


---

### Example:  unequal probability sample `anthuneq`

.large[
But we can't see the fact that shorter men are overrepresented in the usual data scatterplot

&lt;img src="week_10_regression_files/figure-html/unnamed-chunk-7-1.svg" style="display: block; margin: auto;" /&gt;

]

---

### Example:  unequal probability sample `anthuneq`

.large[
- `svyplot`: circle size is proportional to sampling weight


```r
anthuneq_design &lt;- svydesign(id=~1, weight = ~wt, data= anthuneq)
*svyplot(jitter(height) ~ jitter(finger),
*       design = anthuneq_design)
```
]

--

.large[
- `svyplot`: `style="hex"` uses hexagonal binning that sums weights by bin groups
  - may need to install `hexbin` package
  

```r
svyplot(jitter(height) ~ jitter(finger), 
        design = anthuneq_design, 
*       style = "hex")
```

]

---

### Example:  unequal probability sample `anthuneq`

.large[
`svyplot`: circle size is proportional to sampling weight
&lt;img src="week_10_regression_files/figure-html/unnamed-chunk-10-1.svg" style="display: block; margin: auto;" /&gt;

]

---

### Example:  unequal probability sample `anthuneq`

.large[
`svyplot`: `hex` style (visually better for larger data sets)
&lt;img src="week_10_regression_files/figure-html/unnamed-chunk-11-1.svg" style="display: block; margin: auto;" /&gt;

]

---

### Example:  unequal probability sample `anthuneq`

.large[
- Model-based estimation:

```r
anthuneq_lm &lt;- lm(height ~ finger, data = anthuneq)   # model-based
broom::tidy(anthuneq_lm)
## # A tibble: 2 x 5
##   term        estimate std.error statistic  p.value
##   &lt;chr&gt;          &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;
## 1 (Intercept)    43.4      2.55      17.0  1.15e-40
## 2 finger          1.79     0.226      7.90 1.87e-13
```

]

---

### Example:  unequal probability sample `anthuneq`

.large[
- Design-based estimation:

```r
anthuneq_svylm &lt;- svyglm(height ~ finger, design=anthuneq_design)
broom::tidy(anthuneq_svylm)
## # A tibble: 2 x 5
##   term        estimate std.error statistic     p.value
##   &lt;chr&gt;          &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;       &lt;dbl&gt;
## 1 (Intercept)    30.2      6.63       4.56 0.00000913 
## 2 finger          3.05     0.588      5.19 0.000000512
```

]

---

### Example:  unequal probability sample `anthuneq`

&lt;img src="week_10_regression_files/figure-html/unnamed-chunk-14-1.svg" style="display: block; margin: auto;" /&gt;


---

### Example:  unequal probability sample `anthuneq`

.large[
- Finite population:
`$$B_1 = 3.056, \ \ B_0 =  30.179$$`

- Model-based slope estimate:
`$$\hat{\beta}_1 = 1.7886 (SE = 0.2263), \ \ \hat{\beta}_0 = 43.4079 (SE=2.5481)$$`

- Design-based slope estimate:
`$$\hat{B}_1 = 3.0550 (SE = 0.5883), \ \ \hat{B}_0 = 30.1753 (SE=6.6284)$$`

- Inference about the *population* of all criminals is not estimated correctly by the model-based solution!
]



---

### `ggplot2` options

- Add `size` aesthetic to make circle size is proportional to sampling weight
- Add `weight` aesthetic to `geom_smooth` to add the weighted (design-based) regression line

```r
ggplot(anthuneq, aes(x = finger, y = height)) + 
* geom_jitter(aes(size = wt), shape = 1, show.legend = FALSE)  +
* geom_smooth(aes(weight = wt), method = "lm", se = FALSE)
```

&lt;img src="week_10_regression_files/figure-html/unnamed-chunk-15-1.svg" style="display: block; margin: auto;" /&gt;

    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
