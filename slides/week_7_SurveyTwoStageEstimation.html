<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Survey package: Two stage cluster sampling</title>
    <meta charset="utf-8" />
    <meta name="author" content="Stat 260, St. Clair" />
    <link href="libs/remark-css/default.css" rel="stylesheet" />
    <link href="libs/remark-css/default-fonts.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# <code>Survey</code> package: Two stage cluster sampling
## Week 7
### Stat 260, St. Clair

---







### Two-stage cluster sampling estimation 

The data format for two-stage cluster sampling data must be at the **SSU-level** ("raw" data)

  - unlike one-stage data, the `survey` package cannot get correct estimates/SE from "cluster-level" data summaries

---

### Two-stage cluster sampling estimation 


```r
&gt; twostage_design &lt;- svydesign(id = ~PSU + SSU, 
+                           fpc = ~N + Mi,    
+                           weights = ~wts,   
+                           data = mydata)
&gt; svymean(~y, twostage_design)   # ratio mean estimate
&gt; svytotal(~y, twostage_design)  # unbiased total estimate
```

- `svytotal` will give you unbiased total estimates `\(\hat{t}_{unb}\)`

  - for **mean**: divide by `\(M_0\)`, if known, to get `\(\hat{\bar{y}}_{unb} = \hat{t}_{unb}/M_0\)`, SE and CI

- `svymean` will give you ratio (biased) mean estimates `\(\hat{\bar{y}}_{r}\)`

  - for **total**: multiply by `\(M_0\)`, if known, to get `\(\hat{t}_{r} = M_0\hat{\bar{y}}_{r}\)`, SE and CI

---

### California API scores


- A SRS of 40 school districts was selected from the 757 districts in the state. 

- Data from a SRS of schools within each selected district was collected.    


```r
&gt; schools &lt;- read.csv("http://math.carleton.edu/kstclair/data/california_cluster.csv")
&gt; glimpse(schools)
Rows: 126
Columns: 10
$ sname         &lt;chr&gt; "Alta-Dutch Flat Elementary", "Tenaya Elementary", "P...
$ snum          &lt;int&gt; 3269, 5979, 4958, 4957, 4956, 4915, 2548, 2550, 2549,...
$ dname         &lt;chr&gt; "Alta-Dutch Flat Elem", "Big Oak Flat-Grvlnd Unif", "...
$ dnum          &lt;int&gt; 15, 63, 83, 83, 83, 117, 132, 132, 132, 152, 152, 152...
$ api00         &lt;int&gt; 821, 773, 600, 740, 716, 811, 472, 520, 568, 591, 544...
$ growth        &lt;int&gt; 36, 55, -32, 0, 5, 32, 40, 26, -21, 6, -10, 29, 14, 2...
$ meals         &lt;int&gt; 27, 43, 33, 11, 5, 25, 78, 76, 68, 42, 63, 54, 0, 4, ...
$ ell           &lt;int&gt; 0, 0, 5, 4, 2, 5, 38, 34, 34, 23, 42, 24, 3, 6, 2, 1,...
$ enroll        &lt;int&gt; 152, 312, 173, 201, 147, 234, 184, 512, 543, 332, 217...
$ district_size &lt;int&gt; 1, 1, 3, 3, 3, 1, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 1, 4,...
```

---

### California API scores:  `id` entries

- PSU: district

  - `dname` or `dnum`
 
- SSU: school

  - `sname` or `snum`

---

### California API scores:  SSU


`\(M_i\)` = number of schools in district `\(i\)`
  
  - `district_size`


```r
&gt; schools_by_district &lt;- schools %&gt;% 
+   group_by(dnum) %&gt;%  # group by cluster (district number)
+   summarize(M_i = first(district_size), 
+             m_i = n() )  # sample size per cluster
&gt; summary(schools_by_district$M_i)
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
  1.000   1.750   3.000   6.775   5.000  72.000 
```


---

### California API scores:  SSU


`\(m_i\)` = number of *sampled* schools in district `\(i\)`
  
  - not given in the data set


```r
&gt; summary(schools_by_district$m_i)
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
   1.00    1.75    3.00    3.15    5.00    5.00 
```


Add `\(m_i\)` to the original data set with `mutate`:

```r
&gt; schools &lt;- schools %&gt;%
+     group_by(dnum) %&gt;% # group by cluster (district number)
+     mutate(m_i = n())  #  m_i = sample size per cluster
&gt; schools %&gt;% select(dnum, m_i) %&gt;% glimpse()
Rows: 126
Columns: 2
Groups: dnum [40]
$ dnum &lt;int&gt; 15, 63, 83, 83, 83, 117, 132, 132, 132, 152, 152, 152, 173, 17...
$ m_i  &lt;int&gt; 1, 1, 3, 3, 3, 1, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 1, 4, 4, 4, 4,...
```


---

### California API scores: weights

- Two-stage weights are `\(\dfrac{NM_i}{nm_i}\)`


```r
&gt; schools$N &lt;- 757  # N
&gt; schools$n &lt;- 40   # n 
&gt; schools$wts &lt;- (757/40)*schools$district_size/schools$m_i
&gt; summary(schools$wts)
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
  18.93   18.93   18.93   40.70   26.50  272.52 
```

---

### California API scores: design



```r
&gt; schools_design &lt;- svydesign(id= ~dnum + snum, 
+                             fpc= ~N + district_size, 
+                             weights = ~wts, 
+                             data=schools)
```

---

### California API scores



```r
&gt; svymean(~growth, schools_design, deff = TRUE) # ratio est.
         mean     SE   DEff
growth 25.778  2.842 1.5794
&gt; svytotal(~growth, schools_design, deff = TRUE) # unbiased est.
        total     SE   DEff
growth 132206  41184 12.609
```

---

### Lohr Examples 5.7


```r
&gt; coots &lt;- read.csv("http://math.carleton.edu/kstclair/data/coots.csv")
&gt; library(dplyr)
&gt; glimpse(coots)
Rows: 368
Columns: 6
$ clutch  &lt;int&gt; 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 1...
$ csize   &lt;int&gt; 13, 13, 13, 13, 6, 6, 11, 11, 10, 10, 13, 13, 9, 9, 11, 11,...
$ length  &lt;dbl&gt; 44.30, 45.90, 49.20, 48.70, 51.05, 49.35, 49.20, 48.55, 49....
$ breadth &lt;dbl&gt; 31.10, 32.70, 34.40, 32.70, 34.25, 34.40, 31.55, 33.10, 34....
$ volume  &lt;dbl&gt; 3.7957569, 3.9328497, 4.2156036, 4.1727621, 0.9317646, 0.90...
$ tmt     &lt;int&gt; 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,...
```

- `clutch`: clutch (nest) identifier (cluster)

- `csize`: clutch size (cluster size) `\(M_i\)`

- `volume`: egg volume

---

### Lohr Examples 5.7: `id` entries

- PSU: clutch

  - `clutch` identifies clusters

- SSU: egg

  - Nothing to identify eggs 
  
  - Add in a row number variable to do so (using `~1` doesn't work!)


```r
&gt; coots$elem.id &lt;- 1:nrow(coots)   # unique id for each egg
```

---

### Lohr Examples 5.7: SSU info

`\(M_i\)` = number of eggs in clutch `\(i\)`  
  
  - `csize`
  

```r
&gt; clutch_summary &lt;- coots %&gt;%
+   group_by(clutch) %&gt;% 
+   summarize(Mi = first(csize),   # size of each clutch
+             mi = n() )            # sample size of each clutch
&gt; summary(clutch_summary$Mi)
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
  5.000   8.750  10.000   9.549  11.000  13.000 
```

---

### Lohr Examples 5.7: SSU info

`\(m_i\)` = number of *sampled* eggs in clutch `\(i\)`  
  
  - not given in the data set
  

```r
&gt; summary(clutch_summary$mi)
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
      2       2       2       2       2       2 
```

Add `\(m_i\)` to the original data set with `mutate`:

```r
&gt; coots &lt;- coots %&gt;% 
+   group_by(clutch) %&gt;% 
+   mutate(mi = n()) 
&gt; coots
# A tibble: 368 x 8
# Groups:   clutch [184]
   clutch csize length breadth volume   tmt elem.id    mi
    &lt;int&gt; &lt;int&gt;  &lt;dbl&gt;   &lt;dbl&gt;  &lt;dbl&gt; &lt;int&gt;   &lt;int&gt; &lt;int&gt;
 1      1    13   44.3    31.1  3.80      1       1     2
 2      1    13   45.9    32.7  3.93      1       2     2
 3      2    13   49.2    34.4  4.22      1       3     2
 4      2    13   48.7    32.7  4.17      1       4     2
 5      3     6   51.0    34.2  0.932     0       5     2
 6      3     6   49.4    34.4  0.901     0       6     2
 7      4    11   49.2    31.6  3.02      1       7     2
 8      4    11   48.6    33.1  2.98      1       8     2
 9      5    10   49.4    34.6  2.50      1       9     2
10      5    10   49.0    35.0  2.49      1      10     2
# ... with 358 more rows
```




---

### Lohr Examples 5.7: PSU info

`\(N\)` = number of clutches in the population 
  
  - unknown!
  
- But this is fine for estimating a **mean/proportion** 
  
  - cluster sampling weights `\(N/n\)`: self-weighting design
  
  - like not knowing `\(N\)` for a SRS 

---

### Lohr Examples 5.7: weights with `\(N\)` unknown

- **Sampling weights** are proportional to `\(\dfrac{M_i}{m_i}\)`:

```r
&gt; coots$wts &lt;- coots$csize/coots$mi  
&gt; summary(coots$wts)
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
  2.500   4.375   5.000   4.774   5.500   6.500 
```

  

---

### Lohr Examples 5.7: design




```r
&gt; coots_design &lt;- svydesign(id = ~clutch + elem.id, 
+                         weights = ~wts, 
+                         data = coots)
&gt; summary(coots_design)
2 - level Cluster Sampling design (with replacement)
With (184, 368) clusters.
svydesign(id = ~clutch + elem.id, weights = ~wts, data = coots)
Probabilities:
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
 0.1538  0.1818  0.2000  0.2187  0.2292  0.4000 
Data variables:
[1] "clutch"  "csize"   "length"  "breadth" "volume"  "tmt"     "elem.id"
[8] "mi"      "wts"    
```

---

### Lohr Examples 5.7

- The SE won't include the FPCs


```r
&gt; mn.obj &lt;- svymean(~volume, coots_design, deff=T)
&gt; mn.obj  #ratio estimate of pop. mean without FPC in SE
          mean      SE   DEff
volume 2.49058 0.06104 2.5755
&gt; confint(mn.obj, df=degf(coots_design))
          2.5 %   97.5 %
volume 2.370145 2.611012
```


---

### Lohr Examples 5.7


- The sampling weights are just `\(\dfrac{M_i}{m_i}\)` instead of `\(\dfrac{NM_i}{nm_i}\)`

  - We need exact sampling weights to estimate any **total**


```r
&gt; svytotal(~volume, coots_design, deff=T)  # INCORRECT 
         total      SE   DEff
volume 4375.95  165.89 6.1621
&gt; sum(coots$volume*coots$wts)
[1] 4375.947
```

- 4375.95 is the estimated **total volume** of the **sampled clutches**

  - NOT the **total volume** of **all** clutches in the **population**.
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
