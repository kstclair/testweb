---
title: "Ch. 11 topics: Regression with complex survey data"
author: "Math 255, St. Clair"
output:
  xaringan::moon_reader:
    chakra: libs/remark-latest.min.js
    css: [default, rladies,hygge]    
    lib_dir: libs
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
---

```{r setup, include=FALSE}
options(htmltools.dir.version = FALSE)
knitr::opts_chunk$set(collapse=TRUE, prompt=TRUE, comment=NULL, message = FALSE, warning = FALSE, fig.height = 4.5, fig.width = 7, dev='svg', fig.align = 'center')
library(survey)
library(tidyverse)
```

### Goal:

.large[
- A regression model describes how a response $y$ varies as a function of explanatory variables $x$

- Typical regression modeling goals:

1. Describe the relationship between variables.  

2. Predict a response $y$ given $x$

3. Determine how changes in $x$ **cause** changes in $y$
]

---

### Model-based regression: Math 245

.large[
- Build a theoretical "universal" model for $y$ given $x$ that holds across populations

-  Describe a "data generating model" (DGM)

    - a stochastic model that “generates” the particular finite population of individuals

- A model comes with structural probabilistic assumptions that must be checked
]

---

### Model-based regression: Math 245

.large[
- Variables: 
    - Response $Y$
    - Covariates (predictors/explanatory) $x$

- Simple linear regression model: describes the **conditional probability distribution of $\pmb{y}$ given $\pmb{x}$**

$$Y_i \mid x_i \sim N(\mu_i, \sigma^2) \ \ \ \mu_i = \beta_0 + \beta_1 x_i$$
- Model assumptions:

(1) Linear relationship

(2) Constant variance

(3) Normally distributed 

(4) Independence
]

---

### Model-based regression: estimation

.large[
- Obtain data we believe was generated by a particular DGP 

- Use **maximum likelihood** inference methods to derive parameter estimates and SE for theoretical parameters $\beta_0$, $\beta_1$, and $\sigma$

    - only based on the model assumptions, not sampling weights!
]

--

.large[
- e.g. the slope estimate:
$$\hat{\beta_1} = \dfrac{\sum_{i=1}^n x_iy_i - \dfrac{1}{n} \sum_{i=1}^n x_i \sum_{i=1}^n y_i}{ \sum_{i=1}^n x^2_i -  \dfrac{1}{n}\left(\sum_{i=1}^n x_i \right)^2}$$
- But estimates and their SE's are highly dependent upon model assumptions (1), (2) and (4)
]


---

### Design-based regression: Math 255

.large[
- Population parameters $B_0$ and $B_1$ are the "best fit" intercept and slope for the population trend
$$y = B_0 + B_1 x$$
- "best fit" means $B_0$ and $B_1$ minimize

$$\sum_{i=1}^N (y_i - B_0 - B_1x_i)^2$$
]
--

.large[
- e.g. the population slope is
$$B_1 = \dfrac{\sum_{i=1}^N x_iy_i - \dfrac{1}{N} \sum_{i=1}^N x_i \sum_{i=1}^N y_i}{ \sum_{i=1}^N x^2_i -  \dfrac{1}{N}\left(\sum_{i=1}^N x_i \right)^2}$$
]

---

### Design-based regression: estimation

.large[
-  $B_1$ is just another population parameter to estimate using sampling weights

    - Model fit is not important since there is no model structure!
]

--
.large[
- e.g $B_1$ is just a function of population totals so we use an appropriately weighted estimate:
$$\hat{B}_1 = \dfrac{\sum_{i=1}^n w_ix_iy_i - \dfrac{1}{\sum_{i=1}^n w_i} \sum_{i=1}^n w_ix_i \sum_{i=1}^n w_iy_i}{ \sum_{i=1}^n w_ix^2_i -  \dfrac{1}{\sum_{i=1}^n w_i}\left(\sum_{i=1}^n w_ix_i \right)^2}$$
- Shouldn't apply design-based parameter estimates $\hat{B}_0, \hat{B}_1$ to other finite populations.

]
---

### Design-based vs model-based regression

.large[
- Can think of the finite population of $y_i$'s as being a realization from a "universal" DGM described earlier

    - then $B$'s should be close to $\beta$'s 
]

--
.large[
- If **estimates** of $B_1$ and $\beta_1$ differ by a lot, then this could indicate that the **model** is inadequate 

    - the model doesn't fit all subpopulations well
    
    - sampling weights are likely accounting for some unmeasured variable that is important to the relationship between $y$ and $x$
]

--

.large[
- Models can include design variables

    - use stratification variables as covariates
    
    - fit a mixed-effects model with random cluster effects (Math 345, Spring '20)
]

---

### Example: The population

.large[
- `anthrop` in `SDaA`
    - A population of 3000 late 19th century criminals (anthrop.csv)

- Goal: model height as a function of finger length

```{r}
library(SDaA)
pop <- anthrop  # the finite pop.
str(pop)
pop.lm <- lm(height ~ finger, data=pop)
pop.lm
```
]

---

### Example:  The population
.large[
```{r}
plot(jitter(height) ~ jitter(finger), data=pop, main ="Population")
abline(pop.lm, col="red")
```

]

---

### Example: The SRS of size 200 `anthsrs`
.large[
```{r, fig.height=4}
plot(jitter(height) ~ jitter(finger), data=pop, main ="Population & SRS", col="red")
abline(pop.lm, col="red")
points(jitter(anthsrs$finger), jitter(anthsrs$height), pch=19)
legend("topleft",col=c("red","black"),lty=c(1,NA),pch=c(1,19),legend=c("population","SRS"))
```

]

---

### Example: The SRS of size 200 `anthsrs`

.large[
- With an SRS, the model- and design-based estimates are the same (self-weighting).

- Model-based estimation:
```{r}
anthsrs.lm<- lm(height~finger, data= anthsrs)   # model-based
summary(anthsrs.lm)
```

]

---

### Example: The SRS of size 200 `anthsrs`

.large[
- Design-based estimation:
```{r}
anthsrs$N<- 3000
anthsrs$wts<- 3000/200
anthsrs.design<- svydesign(id= ~1, fpc= ~N, weights= ~wts, data=anthsrs)
anthsrs.svylm<- svyglm(height ~ finger, design=anthsrs.design)
summary(anthsrs.svylm)
```

]

---

### Example: The SRS of size 200 `anthsrs`

.large[
- Finite population:
$$B_1 = 3.056, \ \ B_0 =  30.179$$

- Model-based slope estimate:
$$\hat{\beta}_1 = 3.0453 (SE = 0.2217), \ \ \hat{\beta}_0 = 30.3162 (SE=2.5668)$$

- Design-based slope estimate:
$$\hat{B}_1 = 3.0453 (SE = 0.2126), \ \ \hat{B}_0 = 30.3162 (SE=2.4574)$$
]

---

### Example:  unequal probability sample `anthuneq`

.large[
Shorter men have a higher inclusion probability
```{r,  echo=FALSE}
plot(jitter(height) ~ jitter(finger), data=pop, main ="Population & Unequal sample", col="red")
abline(pop.lm, col="red")
points(jitter(anthuneq$finger), jitter(anthuneq$height), pch=19)
legend("topleft",col=c("red","black"),lty=c(1,NA),pch=c(1,19),legend=c("population","Unequal"))
```

]

---

### Example:  unequal probability sample `anthuneq`

.large[
But we can't see the fact that shorter men are overrepresented in the usual data scatterplot
```{r, echo=FALSE}
plot(jitter(height) ~ jitter(finger), data=anthuneq, main ="Unequal sample", xlim=c(9.5,13.5), ylim=c(55,75), pch=19)
```

]

---

### Example:  unequal probability sample `anthuneq`

.large[
- `svyplot`: circle size is proportional to sampling weight
```{r, eval=FALSE}
anthuneq.design <- svydesign(id=~1, probs= ~prob, data= anthuneq)
svyplot(jitter(height) ~ jitter(finger), anthuneq.design)
```
]

--
.large[
- `svyplot`: `style="hex"` uses hexagonal binning that sums weights by bin groups
```{r, eval=FALSE}
svyplot(jitter(height) ~ jitter(finger), anthuneq.design, style="hex")
```

]

---

### Example:  unequal probability sample `anthuneq`

.large[
`svyplot`: circle size is proportional to sampling weight
```{r, echo=FALSE}
anthuneq.design <- svydesign(id=~1, probs= ~prob, data= anthuneq)
svyplot(jitter(height) ~ jitter(finger), anthuneq.design, main ="Unequal sample", xlim=c(9.5,13.5), ylim=c(55,75), xlab="finger length", ylab="height")
```

]

---

### Example:  unequal probability sample `anthuneq`

.large[
`svyplot`: `hex` style (visually better for larger data sets)
```{r, echo=FALSE}
svyplot(jitter(height) ~ jitter(finger), anthuneq.design, main ="Unequal sample", xlab="finger length", ylab="height", style="hex")
```

]

---

### Example:  unequal probability sample `anthuneq`

.large[
- Model-based estimation:
```{r}
anthuneq.lm<- lm(height~finger, data= anthuneq)   # model-based
summary(anthuneq.lm)
```

]

---

### Example:  unequal probability sample `anthuneq`

.large[
- Design-based estimation:
```{r}
anthuneq.svylm<- svyglm(height ~ finger, design=anthuneq.design)
summary(anthuneq.svylm)
```

]

---

### Example:  unequal probability sample `anthuneq`

```{r, echo=FALSE}
svyplot(jitter(height) ~jitter(finger), anthuneq.design, xlim=c(9.5,13.5),
ylim=c(55,75), xlab="finger length",ylab="height")
abline(anthuneq.svylm)
abline(anthuneq.lm,lty=2)
abline(pop.lm,lty=3,col="red",lwd=2)
title("Unequal-prob. sample (Fig. 11.5)")
legend("topleft",col=c("black","black","red"),lty=c(1,2,3),
legend=c("design-based","model-based","population"))
```

---

### Example:  unequal probability sample `anthuneq`

.large[
- Finite population:
$$B_1 = 3.056, \ \ B_0 =  30.179$$

- Model-based slope estimate:
$$\hat{\beta}_1 = 1.7886 (SE = 0.2263), \ \ \hat{\beta}_0 = 43.4079 (SE=2.5481)$$

- Design-based slope estimate:
$$\hat{B}_1 = 3.0550 (SE = 0.5883), \ \ \hat{B}_0 = 30.1753 (SE=6.6284)$$

- Inference about the *population* of all criminals is not estimated correctly by the model-based solution!
]
