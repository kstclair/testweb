---
title: "Regression modeling with complex survey data"
author: "Stat 260, St. Clair"
subtitle: "Week 10 (ch 11)"
output:
  xaringan::moon_reader:
    lib_dir: libs
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
---

```{r setup, include=FALSE}
options(htmltools.dir.version = FALSE)
knitr::opts_chunk$set(collapse=TRUE,
                      message = FALSE, warning = FALSE, 
                      fig.height = 5.5, fig.width = 9, 
                      fig.align = 'center', dev = "svg")
library(survey)
library(SDAResources)
library(tidyverse)
```


### Goal:


- A regression model describes how a response $y$ varies as a function of explanatory variables $x$

--

- Typical regression modeling goals:

1. Describe the relationship between variables.  

--

2. Predict a response $y$ given $x$

--

3. Determine how changes in $x$ **cause** changes in $y$


---

### Model-based regression: Stat 230


- Build a theoretical "universal" model for $y$ given $x$ that holds across populations


--

-  Describe a "data generating model" (DGM)

    - a stochastic model that “generates” the particular finite population of individuals


--

- A model comes with structural probabilistic assumptions that must be checked


---

### Model-based regression: Stat 230


- Variables: 
    - Response $Y$
    - Covariates (predictors/explanatory) $x$

--

- Simple linear regression model: describes the **conditional probability distribution of $\pmb{y}$ given $\pmb{x}$**

$$Y_i \mid x_i \sim N(\mu_i, \sigma^2) \ \ \ \mu_i = \beta_0 + \beta_1 x_i$$


--

- Model assumptions:

(1) Linear relationship

(2) Constant variance

(3) Normally distributed 

(4) Independence


---

### Model-based regression: estimation

.large[
- Obtain data we believe was generated by a particular DGP 

- Use **maximum likelihood** inference methods to derive parameter estimates and SE for theoretical parameters $\beta_0$, $\beta_1$, and $\sigma$

    - only based on the model assumptions, not sampling weights!
]

--

.large[
- e.g. the slope estimate:
$$\hat{\beta_1} = \dfrac{\sum_{i=1}^n x_iy_i - \dfrac{1}{n} \sum_{i=1}^n x_i \sum_{i=1}^n y_i}{ \sum_{i=1}^n x^2_i -  \dfrac{1}{n}\left(\sum_{i=1}^n x_i \right)^2}$$
- But estimates and their SE's are highly dependent upon model assumptions (1), (2) and (4)
]


---

### Design-based regression: Stat 260

.large[
- Population parameters $B_0$ and $B_1$ are the "best fit" intercept and slope for the population trend
$$y = B_0 + B_1 x$$
- "best fit" means $B_0$ and $B_1$ minimize

$$\sum_{i=1}^N (y_i - B_0 - B_1x_i)^2$$
]
--

.large[
- e.g. the population slope is
$$B_1 = \dfrac{\sum_{i=1}^N x_iy_i - \dfrac{1}{N} \sum_{i=1}^N x_i \sum_{i=1}^N y_i}{ \sum_{i=1}^N x^2_i -  \dfrac{1}{N}\left(\sum_{i=1}^N x_i \right)^2}$$
]

---

### Design-based regression: estimation

.large[
-  $B_1$ is just another population parameter to estimate using sampling weights

    - Model fit is not important since there is no model structure!
]

--

.large[
- e.g $B_1$ is just a function of population totals so we use an appropriately weighted estimate:
$$\hat{B}_1 = \dfrac{\sum_{i=1}^n w_ix_iy_i - \dfrac{1}{\sum_{i=1}^n w_i} \sum_{i=1}^n w_ix_i \sum_{i=1}^n w_iy_i}{ \sum_{i=1}^n w_ix^2_i -  \dfrac{1}{\sum_{i=1}^n w_i}\left(\sum_{i=1}^n w_ix_i \right)^2}$$
- Shouldn't apply design-based parameter estimates $\hat{B}_0, \hat{B}_1$ to other finite populations.

]

---

### Design-based vs model-based regression

.large[
- Can think of the finite population of $y_i$'s as being a realization from a "universal" DGM described earlier

    - then $B$'s should be close to $\beta$'s 
]

--
.large[
- If **estimates** of $B_1$ and $\beta_1$ differ by a lot, then this could indicate that the **model** is inadequate 

    - the model doesn't fit all subpopulations well
    
    - sampling weights are likely accounting for some unmeasured variable that is important to the relationship between $y$ and $x$
]

--

.large[
- Models can include design variables

    - use stratification variables as covariates
    
    - fit a mixed-effects model with random cluster effects (Stat 330)
]

---

### Example: The population

.large[
- `anthrop` in `SDaA`
    - A population of 3000 late 19th century "criminals" (anthrop.csv)

- Goal: model height as a function of finger length

```{r}
pop <- anthrop  # the finite pop.
str(pop)
pop_lm <- lm(height ~ finger, data=pop)
pop_lm
```
]

---

### Example:  The population
.large[

```{r, echo = FALSE}
ggplot(pop, aes(x = finger, y = height)) + 
  geom_jitter() + 
  geom_smooth(method = "lm", color = "red", se = FALSE) + 
  labs(title = "Population")
```

]

---

### Example: The SRS of size 200 `anthsrs`
.large[

```{r, echo = FALSE}
ggplot(pop, aes(x = finger, y = height)) + 
  geom_jitter(aes(color = "Population")) + 
  geom_smooth(method = "lm", color = "red", se = FALSE,aes(color = "Population"))+ 
  labs(title = "Population and SRS", color = "") + 
  geom_jitter(data = anthsrs, size = 2, aes(color = "SRS")) + 
  scale_color_manual(values = c("SRS" = "black", "Population" = "red"))
```


]

---

### Example: The SRS of size 200 `anthsrs`

.large[
- With an SRS, the model- and design-based estimates are the same (self-weighting).

- Model-based estimation:
```{r}
anthsrs_lm<- lm(height~finger, data= anthsrs)   # model-based
broom::tidy(anthsrs_lm)
```

]

---

### Example: The SRS of size 200 `anthsrs`

.large[
- Design-based estimation:
```{r}
anthsrs$N<- 3000
anthsrs$wts<- 3000/200
anthsrs_design<- svydesign(id = ~1, 
                           fpc = ~N, 
                           weights = ~wts, 
                           data = anthsrs)
anthsrs_svylm<- svyglm(height ~ finger, 
                       design = anthsrs_design)
broom::tidy(anthsrs_svylm)
```

]

---

### Example: The SRS of size 200 `anthsrs`

.large[
- Finite population:
$$B_1 = 3.056, \ \ B_0 =  30.179$$

- Model-based slope estimate:
$$\hat{\beta}_1 = 3.0453 (SE = 0.2217), \ \ \hat{\beta}_0 = 30.3162 (SE=2.5668)$$

- Design-based slope estimate:
$$\hat{B}_1 = 3.0453 (SE = 0.2126), \ \ \hat{B}_0 = 30.3162 (SE=2.4574)$$
]

---

### Example:  unequal probability sample `anthuneq`

Shorter men have a higher inclusion probability
```{r, echo = FALSE}
ggplot(pop, aes(x = finger, y = height)) + 
  geom_jitter(aes(color = "Population")) + 
  geom_smooth(method = "lm", color = "red", se = FALSE,
              aes(color = "Population"))+ 
  labs(title = "Population and Unequal probability sample", color = "") + 
  geom_jitter(data = anthuneq, size = 2, aes(color = "Unequal")) + 
  scale_color_manual(values = c("Unequal" = "black", "Population" = "red"))
```


---

### Example:  unequal probability sample `anthuneq`

.large[
But we can't see the fact that shorter men are overrepresented in the usual data scatterplot

```{r, echo = FALSE}
ggplot(anthuneq, aes(x = finger, y = height)) + 
  geom_jitter() + 
  labs(title = "Unequal probability sample") 
```

]

---

### Example:  unequal probability sample `anthuneq`

.large[
- `svyplot`: circle size is proportional to sampling weight

```{r, eval=FALSE}
anthuneq_design <- svydesign(id=~1, weight = ~wt, data= anthuneq)
svyplot(jitter(height) ~ jitter(finger), #<<
        design = anthuneq_design) #<<
```
]

--

.large[
- `svyplot`: `style="hex"` uses hexagonal binning that sums weights by bin groups
  - may need to install `hexbin` package
  
```{r, eval=FALSE}
svyplot(jitter(height) ~ jitter(finger), 
        design = anthuneq_design, 
        style = "hex") #<<
```

]

---

### Example:  unequal probability sample `anthuneq`

.large[
`svyplot`: circle size is proportional to sampling weight
```{r, echo=FALSE}
anthuneq_design <- svydesign(id=~1, weight = ~wt, data= anthuneq)
svyplot(jitter(height) ~ jitter(finger), anthuneq_design, 
        main ="Unequal sample", 
        xlim=c(9.5,13.5), ylim=c(55,75), 
        xlab="finger length", ylab="height")
```

]

---

### Example:  unequal probability sample `anthuneq`

.large[
`svyplot`: `hex` style (visually better for larger data sets)
```{r, echo=FALSE}
svyplot(jitter(height) ~ jitter(finger), anthuneq_design, 
        main ="Unequal sample", xlab="finger length", 
        ylab="height", style="hex")
```

]

---

### Example:  unequal probability sample `anthuneq`

.large[
- Model-based estimation:
```{r}
anthuneq_lm <- lm(height ~ finger, data = anthuneq)   # model-based
broom::tidy(anthuneq_lm)
```

]

---

### Example:  unequal probability sample `anthuneq`

.large[
- Design-based estimation:
```{r}
anthuneq_svylm <- svyglm(height ~ finger, design=anthuneq_design)
broom::tidy(anthuneq_svylm)
```

]

---

### Example:  unequal probability sample `anthuneq`

```{r, echo=FALSE}
df <- data.frame(type = c("1. population","2. model-based","3. design-based"),
                 intercept = c(pop_lm$coefficients[1], anthuneq_lm$coefficients[1],anthsrs_svylm$coefficients[1]),
                 slope = c(pop_lm$coefficients[2], anthuneq_lm$coefficients[2],anthsrs_svylm$coefficients[2]))
ggplot(anthuneq, aes()) + 
  geom_jitter(aes(x = finger, y = height, size = wt), 
              shape = 1, show.legend = FALSE) + 
  scale_x_continuous(lim=c(9.5,13.5)) + 
  scale_y_continuous(lim=c(55,75)) + 
  geom_abline(data = df, aes(color = type, linetype = type, 
              intercept = intercept, slope= slope), size = 1.1) + 
  scale_color_manual(values = c("red","blue","black")) + 
  labs(title = "Unequal probability sample")
```


---

### Example:  unequal probability sample `anthuneq`

.large[
- Finite population:
$$B_1 = 3.056, \ \ B_0 =  30.179$$

- Model-based slope estimate:
$$\hat{\beta}_1 = 1.7886 (SE = 0.2263), \ \ \hat{\beta}_0 = 43.4079 (SE=2.5481)$$

- Design-based slope estimate:
$$\hat{B}_1 = 3.0550 (SE = 0.5883), \ \ \hat{B}_0 = 30.1753 (SE=6.6284)$$

- Inference about the *population* of all criminals is not estimated correctly by the model-based solution!
]



---

### `ggplot2` options

- Add `size` aesthetic to make circle size is proportional to sampling weight
- Add `weight` aesthetic to `geom_smooth` to add the weighted (design-based) regression line
```{r, fig.height=4}
ggplot(anthuneq, aes(x = finger, y = height)) + 
  geom_jitter(aes(size = wt), shape = 1, show.legend = FALSE)  + #<<
  geom_smooth(aes(weight = wt), method = "lm", se = FALSE) #<<
```

